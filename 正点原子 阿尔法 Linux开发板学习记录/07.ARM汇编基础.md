# GNU 汇编语法
`label: instruction@comment`
- label 标号，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到指令的地址，标号也可以用来表示数据地址。注意label后的":"，任何以 “:”结尾的标识符都会被识别为一个标号。
- instruction 指令，也就是汇编指令或者伪指令。
- @符号表示后面的是注释，即comment为注释

**ARM中的指令，伪指令，伪操作，寄存器名等可以全部使用大写，也可以全部使用小写，但是不能大小写混用。**

用户可以使用.section伪操作来定义一个段，汇编系统中预定义了一些段名。
- .text 表示代码段
- .data 初始化的数据段
- .bss 未初始化的数据段
- .rodata 只读数据段
我们当然可以自己使用.section 来定义一个段，每个段以段名开始，以下一段名或者文件结尾结束，比如：
`.section .testsection @定义一个 testsetcion 段`


汇编程序的入口标号是 `_start` ， 不过我们也可以在链接脚本中使用 ENTRY 来指明其他的入口点。下面的代码中使用 `_start` 作为入口标号
```
.global _start

_start:

ldr r0, =0x12 @r0=0x12
```
`.global是伪操作，表示_start是一个全局标号`

**常见的伪操作：**
- .byte    定义单字节数据，比如.byte 0x12。
- .short   定义双字节数据，比如.short 0x1234。
- .long    定义一个 4 字节数据，比如.long 0x12345678。
- .equ     赋值语句，格式为： .equ 变量名，表达式，比如.equ num, 0x12，表示 num=0x12。
- .align   数据字节对齐，比如： .align 4 表示 4 字节对齐。
- .end     表示源文件结束。
- .global 定义一个全局符号，格式为： .global symbol，比如： .global _start。

**GNU汇编函数**
```
函数名：
	函数体
	返回语句
```
GNU汇编函数的返回语句不是必须的。
Example
```
Underfined_Handler:
	ldr r0, = Undefined_Handler
	bx r0
```
`bx`指令是返回指令，函数返回语句不是必须的。

# 常用的汇编指令

## 处理器内部数据传输指令
| 指令 | 目的 | 源   | 描述                               |
| ---- | ---- | ---- | ---------------------------------- |
| MOV  | R0   | R1   | 将R1中的数据复制到R0中             |
| MRS  | R0   | CPSR | 将特殊寄存器CPSR中的数据复制到R0中 |
| MSR  | CPSR | R1   | 将R1中的数据复制到特殊寄存器CPSR里 | 

Example
```
MOV R0, R1      @将寄存器R1中的数据传递给R0
MOV R0, #0X12   @将立即数0X12传递给寄存器R0, 即R0 = 0X12
MRS R0, CPSR    @将特殊寄存器CPSR里面的数据传递给R0，即R0=CPSR
MSR CPSR, R0    @将R0中的数据复制到CPSR中，即CPSR=R0
```

## 存储器访问指令
ARM 不能直接访问存储器(RAM/ROM)，需要借助存储器指令访问，一般先将要配置的值写到Rx(x=0~12)寄存器中，然后借助存储器访问指令将Rx中的数据写入到I.MX6UL的寄存器中。读取的过程与写入过程相反。
| 指令                  | 描述                                       |
| --------------------- | ------------------------------------------ |
| LDR Rd, [Rn, #offset] | 从存储器 Rn+offser的位置读取数据存放到Rd中 |
| STR Rd, [Rn, #offset] | 将Rd中的数据写入到存储器中的Rn+offset位置  | 


LDR指令主要用于从存储加载数据到寄存器Rx中，LDR也可以将一个立即数加载到Rx中，LDR加载立即数的时候要使用"="而不是“#”， 在嵌入式开发中， LDR最常用的就是读取CPU寄存器的值。
**Example**
读取I.MX6UL 寄存器 GPIO1_GDIR中的值
```
LDR R0, =0X0209C004     @将寄存器地址0X0209C004加载到R0中，即R0=0X0209C004
LDR R1, [R1]            @读取地址 0X0209C004中的数据到R1寄存器中
```
写数据到寄存器
```
LDR R0, =0X0209C004     @将寄存器地址加载到R0中
LDR R1, =0X20000002     @R1保存将要写入到寄存器的值
STR R1,[R0]             @将R1中的值写入到R0所保存的地址中
```

LDR 和 STR 都是按照字进行读取和写入的，也就是操作的 32 位数据，如果要按照字节、半字进行操作的话可以在指令“LDR”后面加上 B 或 H，比如按字节操作的指令就是 LDRB 和STRB，按半字操作的指令就是 LDRH 和 STRH。

## 压栈和出栈指令
我们通常会在 A 函数中调用 B 函数，当 B 函数执行完以后再回到 A 函数继续执行。要想再跳回 A 函数以后代码能够接着正常运行，那就必须在跳到 B 函数之前将当前处理器状态保存起来(就是保存 R0~R15 这些寄存器值)，当 B 函数执行完成以后再用前面保存的寄存器值恢复R0~R15 即可。**保存 R0~R15 寄存器的操作就叫做现场保护，恢复 R0~R15 寄存器的操作就叫做恢复现场。** 在进行现场保护的时候需要进行压栈(入栈)操作，恢复现场就要进行出栈操作。压栈的指令为 PUSH，出栈的指令为 POP， PUSH 和 POP 是一种多存储和多加载指令，即可以一次操作多个寄存器数据，他们利用当前的栈指针 SP 来生成地址。
| 指令             | 描述                 |
| ---------------- | -------------------- |
| PUSH \<reg list> | 将寄存器列表存入栈中 |
| POP \<reg list>  | 从栈中恢复寄存器列表 | 

PUSH和POP的另一种写法是 STMFD SP! 和 LDMFD SP!

## 跳转指令
| 指令        | 描述                                                                                                               |
| ----------- | ------------------------------------------------------------------------------------------------------------------ |
| B \<label>  | 跳转到 label，如果跳转范围超过了+/-2KB，可以指定 B.W \<label>使用 32 位版本的跳转指令， 这样可以得到较大范围的跳转 |
| BX \<Rm>    | 间接跳转，跳转到存放于 Rm 中的地址处，并且切换指令集                                                               |
| BL \<label> | 跳转到标号地址，并将返回的地址保存在LR中                                                                           |
| BLX \<Rm>   | 结合 BX 和 BL 的特点，跳转到 Rm 指定的地址，并将返回地址保存在 LR 中，切换指令集。                                 | 

**B指令**
这是最简单的跳转指令， B 指令会将 PC 寄存器的值设置为跳转目标地址， 一旦执行 B 指令， ARM 处理器就会立即跳转到指定的目标地址。如果要调用的函数不会再返回到原来的执行处，那就可以用 B 指令，如下示例：
```
_start:
	ldr sp, =0X80200000       @设置栈指针
	b main                    @跳转到main函数
```
上述代码就是典型的在汇编中初始化 C 运行环境，然后跳转到 C 文件的 main 函数中运行，上述代码只是初始化了 SP 指针，有些处理器还需要做其他的初始化，比如初始化 DDR 等等。因为跳转到 C 文件以后再也不会回到汇编了，所以在第 4 行使用了 B 指令来完成跳转。

**BL指令**
BL 指令相比 B 指令，在跳转之前会在寄存器 LR(R14)中保存当前 PC 寄存器值，所以可以通过将 LR 寄存器中的值重新加载到 PC 中来继续从跳转之前的代码处运行，这是子程序调用一个基本但常用的手段。比如 Cortex-A 处理器的 irq 中断服务函数都是汇编写的，主要用汇编来实现现场的保护和恢复、获取中断号等。但是具体的中断处理过程都是 C 函数，所以就会存在汇编中调用 C 函数的问题。而且当 C 语言版本的中断处理函数执行完成以后是需要返回到irq 汇编中断服务函数，因为还要处理其他的工作，一般是恢复现场。这个时候就不能直接使用B 指令了，因为 B 指令一旦跳转就再也不会回来了，这个时候要使用 BL 指令，示例代码如下：
```
push {r0, r1}       @保存r0, r1
cps #0x13           @进入SVC模式，允许其他中断再次进入

bl system_irqhandler @加载C语言中断处理函数到r2寄存器中

cps #0x12           @进入IRQ模式

pop {r0, r1}        @
str r0, [r1, #0X10] @中断执行完成，写EOIR
```
上述代码中第 5 行就是执行 C 语言版的中断处理函数，当处理完成以后是需要返回来继续执行下面的程序，所以使用了 BL 指令。

## 算术汇编指令
| 指令                | 计算公式                 | 备注             |
| ------------------- | ------------------------ | ---------------- |
| ADD Rd, Rn, Rm      | Rd = Rn + Rm             | 加法指令         |
| ADD Rd, Rn, \#immed | Rd = Rn + \#immed        |                  |
| ADC Rd, Rn, Rm      | Rd = Rn + Rm + 进位      | 带进位的加法运算 |
| ADC Rd, Rn, \#immed | Rd = Rn + \#immed + 进位 |                  |
| SUB Rd, Rn, Rm      | Rd = Rn - Rm             | 减法             |
| SUB Rd, \#immed     | Rd = Rd - \#immed        |                  |
| SUB Rd, Rn, \#immed | Rd = Rn - \#immed        |                  |
| SBC Rd, Rn, \#immed | Rd = Rn - \#immed - 借位 | 带借位的减法     |
| SBC Rd, Rn, Rm      | Rd = Rn - Rm - 借位      |                  |
| MUL Rd, Rn, Rm      | Rd = Rn * Rm             | 乘法             |
| UDIV Rd, Rn, Rm     | Rd = Rn / Rm             | 无符号除法       |
| SDIV Rd, Rn, Rm     | Rd = Rn / Rm             | 有符号除法       | 

## 逻辑运算指令
| 指令           | 计算公式        | 备注     |
| -------------- | --------------- | -------- |
| AND Rd, Rn     | Rd = Rd & Rn    | 按位与   |
| AND Rd, Rn, Rm | Rd = Rn & Rm    |          |
| ORR            |                 | 按位或   |
| BIC Rd, Rn     | Rd = Rd & (~Rn) | 位清除   |
| ORN            |                 | 按位或非 |
| EOR            |                 | 按位异或 | 


