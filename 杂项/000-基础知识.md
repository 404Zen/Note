
# 基础类

## 用预处理指令#define声明一个常数，用以表示一年中有多少秒？（忽略闰年问题）
`#define SECONDS_OF_YEARS          (365*24*60*60)UL`

## 写一个标准宏MIN，这个宏输入两个参数并返回较小的一个。
`#define MIN(A,B)                 ((A) < (B) ? (A) : (B))`

## 用变量a给出下面定义
- 一个整形数。
	`int a;`
- 一个指向整型数的指针。
	`int *a;`
- 一个指向指针的指针，他指向的指针是指向一个整型数。
	`int **a;`
- 一个有10个整型数的数组。
	`int a[10];`
- 一个有10个指针的整型数组。
	`int *a[10];`
- 一个指向10个整型数数组的指针。
	`int (*a)[10];`
- 一个指向函数的指针，该函数有一个整型参数并返回一个整型值。
	`int (*a)(int);`
- 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数。
	`int (*a[10])(int);`

## 关键字static的作用
- 在函数体内，静态变量声明，在函数调用的过程中该变量的值保持不变
- 在函数体外，静态全局变量，该变量仅对当前文件可见。

## 关键字const的作用
- const只读变量，不可以改变该变量的值
- 使用const修饰的变量存放在只读数据段中
- const与define的区别，const定义的是变量，define定义的是常量

## 关键字volatile有什么含义
- 一个定义为volatile的变量，说明这个变量可能会被意想不到的情况改变，每次在使用这个变量时需要重新读取这个变量的值
	- 多线程中被几个任务共享的变量
	- 一个中断服务子程序会访问到的非自动变量
	- 硬件寄存器

### 一个参数既可以是const还可以是volatile吗？
可以，只读的状态寄存器，它是volatile是因为他有可能被意向不到地改变吗，他是const是因为程序不应该试图去修改它。

## 形参和实参的区别
1. 形参变量只有在函数被调用的时候才会分配内存，调用结束后，立即释放内存，所以形参变量只有在函数内部才有效，不能再函数外部使用。
2. 实参可以是常量，变量，表达式，函数等，无论实参是何种类型的数据，在进行函数调用时，他们都必须有确定的值，以便把这些值传给形参，所以应该提前用赋值、输入等办法使实参获得确定值。
3. 实参和形参在数量上、类型上、顺序上必须严格移植，否则会发生“类型不匹配”的错误，当然，如果能够进行自动类型转换，或者进行了强制类型转换，那么实参类型也可以不同于形参的类型。
4. 函数调用中发生的数据传递时单向的，只能把实参的值传递给形参，而不能把形参的值反向地传递给实参，换句话说，一旦完成了数据的传递，实参和形参就再也没有瓜葛了，所以在函数调用的过程中，形参的值发生变化并不会影响实参。

### 一个指针可以是volatile吗？
可以，一个例子是当一个中断服务子程序修改一个指向一个buffer的指针时。

## 位操作
```
a |= (0x01 << n)      // set bit
a &= ~(0x01 << n)     // clr bit
```


## 下面代码输出是什么
```
void func(void)
{
	unsigned int a = 6;
	int b = -20;
	(a + b > 6) ? puts(">6") : puts("<=6");
}
```
输出结果为 >6， 当表达式中存在有符号和无符号类型时，所有的操作数都自动转换为无符号类型。


## 程序的局部变量存在哪里，全局变量存放在哪里，动态申请数据放在哪里。
- 局部变量存在栈区
- 全局变量存在静态区
- 动态申请的数据存在堆区


## 什么是不可重入函数
指一个函数不可以被多个任务同时调用。
- 函数内部使用了静态的数据结构
- 函数内调用了malloc()或者free()函数
- 函数内调用了标准的IO函数

## 代码临界区
值该段代码在执行的时候不允许被打断；
在单片机系统中，进入临界区代码的时候需要关中断，退出时需要开中断。

## 结构体和联合体的区别
- 结构体：占用的内存空间是所有变量所占空间之和，每个成员都有自己的内存地址。
- 联合体：占用的内存空间为最大的成员，提供了一种在同一个地址存储不同的数据类型的方法

## strlen和sizeof的区别
strlen是函数，sizeof是运算符
- strlen 函数用于求解字符串的长度，到 `\0` 结束
- sizeof 用于计算类型或者变量的长度，大部分在编译的时候就已经计算过了。

## 队列与栈的区别
队列：FIFO 先进先出
栈：FILO 先进后出

## 编译的整个过程
预编译，编译，汇编，链接

## 什么是进程，什么是线程
进程是系统中允许的一个实例，程序一旦运行就是一个进程。
线程是进程的一个实体，是进程的一条执行路径。
对于单片机的RTOS来说，都属于并发的线程，从RT-Thread的名字上可以看出。


## 进程间的通讯方式
- 消息队列
- 信号量
- 共享内存
- 套接字
- 管道

## 产生死锁的原因
多个并发进程(线程)因争夺系统资源而产生相互等待的现象。

# 嵌入式

## 嵌入式系统中具有经常要求程序员去访问特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67A9的整型变量的值为0xAA66。编译器是一个纯粹的ANSI编译器。
```
int *ptr;
ptr = (int *)0x67A9;
*ptr = 0xAA66;

// 或者以下方式
*(int *const)(0x67A9) = 0xAA66;
```

## 关于中断
- 中断服务子程序不能返回值
- 中断服务子程序不能传入参数
- 中断服务子程序应该简短且有效率。

## 预处理器标识 `#pargma` 的目的是什么
指定N字节对齐。

## 堆与栈的区别
堆的空间需要手动分配和释放(malloc/free)，栈的空间自动分配和释放；

## 大小端问题
大端：将数据的高位存放在低地址(0x11223344)
小端：将数据的低位存放在低地址(0x44332211)
```
int main()
{
	//强制类型转换会发生截取，下面用char*强制类型转换，截取了第一个字节的地址，然后解引用读取了第一个字节的数据。
	
	int i = 0x11223344;
	
	if(*(char*)(&i) == 0x44)
	{
		printf("small endian\n");
	}
	else
	{
		printf("big endian\n");
	}
}
```

## 分散加载文件
Scatter file 分散加载文件主要在 Keil 链接程序时使用，提供生成映像文件时所需要的信息。它指定了镜像文件内部各段的位置，可以为每段代码或者数据在加载和执行时指定不同的存储位置。

## 单片机中 Code、 RO、RW、ZI的含义
- Code : 程序代码，加载地址和运行地址相同，一般都处于 ROM。
- RO : 程序定义的常量，加载地址和运行地址相同，一般都处于 ROM(`const修饰的常量 #define定义的宏常量`)
- RW : 程序中已经初始化的全局变量，有初值，加载地址和运行地址不同，加载地址位于 ROM，运行地址位于 RAM
- ZI : 程序中未初始化的全局变量，都位于 RAM。
工程中占用的Flash大小：Code + RO + RW
工程中占用的RAM大小：RW + ZI

## UART
![[Pasted image 20230227145029.png]]
- Universial Asynchronous Receiver/Transmitter - 通用异步收发传输器
- 速度较低，可全双工结构上一般由波特率产生器，UART发送器，UART接收器组成。
- UART协议规定，当总线处于空闲时，信号线的状态为高电平，开始进行数据传输时，发送方要先发出一个低电平表示传输字符的开始(与空闲位相反)，数据位可以是5、6、7、8、9位，先发送最低位，分为无校验、奇校验、偶校验、校验位始终为1、校验位始终为0五种校验方式，停止位可以是1、1.5、2位的高电平。
- 串口流控一般用于指示数据终端就绪/数据设置就绪。
- **串口发送数据时，低位在前。**

## IIC
![[Pasted image 20230227140848.png]]
![[Pasted image 20230227140859.png]]
- Inter-Integrated Circuit - 集成电路总线
- 双向，双线，串行，多主控接口标注，速率不快，半双工，同步接口，具有总线仲裁机制。非常适用于器件之间近距离经常性数据通信，可以实现设备组网。
- 起始信号：SCL为高电平时，SDA由高电平向低电平跳变，开始传送数据。
- 结束信号：SCL为高电平时，SDA由低电平向高电平跳变，结束传送数据。
- 应答信号：从机在第九个始终进行拉低回应，表示收到了主机的数据；拉高则表示不应答。
- **SDA传输数据时，高位在前。**




## SPI
![[Pasted image 20230227142944.png]]
- Serial Periphral Interface - 串行外设接口
- 同步，串行，高速，可全双工，可实现多个SPI设备互联，硬件2-4线。
- 四种模式,由(CPOL,CPHA)确定采样边缘。
- 初始化时一般需要配置以下参数
	主从：配置为主机或从机
	模式：全双工，半双工(只发不收，只收不发)
	位宽：8/16位
	时钟线空闲电平：高或低
	数据采样边缘：在第一个时钟边缘采样或第二个时钟边沿采样
	片选信号：硬件控制或软件控制
	时钟速率：一般为某个时钟源的分频
	数据传输方式: 高位在前或者低位在前(MSB or LSB)
	CRC值计算的多项式。





# 网络
## TCP的三次握手与四次挥手
![[Pasted image 20230221130521.png]]
**三次握手**
第一次握手：建立连接，客户端发送连接请求报文，将SYN置为1，Seq Number置为x，然后客户端进入SYN_SEND状态，等待服务器的确认。
第二次握手：服务器收到SYN报文，需要对这个报文进行确认，设置Ack Number为x + 1(Seq Number + 1)，同时，自己还将发送SYN请求信息，Seq Number为y；服务器将以上的信息都放到一个报文段，即SYN+ACK报文，一并发送给客户端。此时服务器进入SYN_RECV状态；
第三次握手：客户端收到SYN+ACK报文，然后就Ack Number设置为Y+1，此时服务器和客户端都进入ESTABLISHED状态，完成TCP三次握手。

**四次挥手**
第一次挥手：主机1(客户端/服务器端都可以)设置Seq Number,向主机2发送一个FIN报文段，此时，主机1进入FIN_WAIT_1状态，这表示主机1没有数据要发送给主机2了；
第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，主机1进入FIN_WAIT_2状态；主机2告诉主机1，我同意你的关闭请求；
第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；
第四次挥手：主机1收到主机2发送的FIN报文之后，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态，主机2收到主机1的ACK报文段之后，就关闭连接。此时主机1等待2MSL后依然没有收到回复，说明对端已经正常关闭，那么此时主机1也可以关闭连接了。

# MQTT协议
[MQTT](https://mqtt.org/) 是一种基于发布/订阅模式的轻量级消息传输协议，专门针对低带宽和不稳定网络环境的物联网应用而设计，可以用极少的代码为联网设备提供实时可靠的消息服务。MQTT 协议广泛应用于物联网、移动互联网、智能硬件、车联网、智慧城市、远程医疗、电力、石油与能源等领域。

## MQTT 必须具备以下几点
1. 简单容易实现
2. 支持QoS(消息发布服务指令)
3. 轻量且节省带宽。
4. 数据无关(不关心Payload的数据格式)
5. 有持续会话感知的能力

## MQTT vs HTTP
1. MQTT的最小报文仅为2字节，比HTTP占用更少的网络开销。
2. MQTT与HTTP都能使用TCP连接，并实现稳定、可靠的网络连接
3. MQTT基于发布订阅模型，HTTP基于请求响应，因此MQTT支持双工通讯
4. MQTT可以实时推送消息，但是HTTP需要通过轮询获取数据更新。
5. MQTT是有状态的,HTTP是无状态的。
6. MQTT可以从连接异常断开恢复，HTTP无法实现此目标。

## MQTT 的 QoS 等级
QoS0 :  消息最多传递一次，如果当时客户端不可用们则会丢失该消息。发布者发送一条消息后，就不再关心有没有发送到对方，也不设置任何的重发机制。
QoS1 :  消息至少传递一次，包含了简单的重发机制，发布者发送消息后等待接收者的ACK，如果没有收到ACK则重发，这种模式能保证消息至少能到达一次，但是无法保证消息重复。
QoS2 : 消息仅传送一次，设计了重发和重复消息发现机制，保证消息到达对方并且严格只到达一次。

## MQTT 安全的双向通信
依赖于发布订阅模型，MQTT 允许再设备和云之间进行双向消息通信，发布订阅模式的优点在于，发布者与订阅者不需要建立直接连接，也不需要同时在线，而是由消息服务器负责所有消息的路由和分发工作。

MQTT支持通过TLS/SSL确保安全的双向通信，同时MQTT协议中提供的客户端ID、用户名和密码允许我们实现应用层的身份验证和授权。

## MQTT 在线状态感知
MQTT提供了心跳保活(Keep Alive)机制。在客户端与服务端长时间无消息交互的情况下，Keep Alive保持连接不被断开，若一旦断开，客户端可即时感知并立即重连。

同时，MQTT设计了遗愿(Last Will)消息，让服务端在发现客户端异常下线的情况下，帮助客户端发布一条遗愿消息到指定的MQTT主题。

另外，部分MQTT服务器如EMQX也提供了上下线事件通知功能，当后端服务订阅了特定主题后，即可收到所有客户端的上下线事件。这样有助于后端服务统一处理客户端的上下线事件。


## MQTT相关的连接参数
### 连接地址
MQTT的连接地址通常包含，服务器的IP或者域名，服务器端口，连接协议。
**基于TCP的MQTT连接**
mqtt 是普通的 TCP 连接，端口一般为 1883，
mqtts 是基于TLS/SSL的安全连接，端口一般为 8883,
**基于 WebSocket 的连接**
ws 是普通的 WebSocket 连接，端口一般为 8083，
wss 是基于WebSocket 的安全连接，端口一般为 8084.

### 客户端ID
MQTT服务器使用客户端ID识别客户端，连接到服务器的每个客户端都必须要有唯一的客户端ID，客户端ID的长度通常为1到23字节的UTF-8字符串

### 用户名与密码
MQTT可以设置用户名和密码来进行相关的认证和授权，但是如果此信息未加密，则用户名和密码将以明文方式传输。如果设置了用户名和密码，则最好使用mqtts或是wss协议。

### 连接超时
连接超时时长，收到都武器连接确认前的等待时间，等待时间内未收到连接确认则认为联机玩失败。

## 保活周期
是一个以秒为单位的时间间隔，当客户端在没有报文发送的时候，将按照Keep Alive设定的值定时向服务端发送心跳报文，确保不被服务端断开连接。

在建立成功连接后，如果服务器没有在Keep Alive 的 1.5 倍时间内收到客户端的任何包，则会认为和客户端之间的连接出现了问题，此时服务器便会断开与客户端的连接。

### 遗嘱消息(Last Will)
遗嘱消息是 MQTT 为那些可能出现**意外断线**的设备提供的将**遗嘱**优雅地发送给其他客户端的能力。设置了遗嘱消息消息的 MQTT 客户端异常下线时，MQTT 服务器会发布该客户端设置的遗嘱消息。


# USB
 ## USB枚举过程
 1. USB主机检测到USB设备插入后，对设备发送总线复位信号，复位设备，设备复位后，设备地址为0地址。
	 1. 主机向设备的地址0的端点0发送数据，请求设备描述符。
	 2. 设备收到主机的请求之后，发送设备描述符给主机。
	 3. 主机接收并确认设备发过来的设备描述符后，向设备回复确认包。
 2. 主机再次复位设备，**进入地址设置阶段**。
	 1. 主机向设备的地址0端点0发送设置地址请求数据包，包里存放着新的设备地址，因此无数据过程。
	 2. 设备收到后，向主机回复一个0字节的状态数据包。
	 3. 主机收到这个0字节的状态数据包之后，会向设备发送一个确认包ACK；
	 4. 设备在收到确认包之后，就可以开始使用新地址了。
3. 主机向新的设备地址端点0发送请求描述符，这次主机将会获取整个设备描述符。
4. 接下来获取配置描述符，接口描述符，端点描述符等等。


# RTOS

## RTOS 相比于裸机的特点
1. 实现功能划分为多个任务
2. 抢占式，任务具有优先级，高优先级任务可以抢占低优先级任务
3. 任务堆栈：每个任务有自己的栈空间。

## 任务调度的方式(FreeRTOS)
- 合作式调度：主要用在资源有限的设备上面，现在已经很少使用了，出于这个原因，后面的FreeRTOS版本不会将合作式调度删掉，但是也不是再进行升级了。
- 抢占式调度：每个任务都有不同的优先级，任务会一直运行直到被高优先级的任务抢占或者遇到阻塞式的API函数，如vTaskDelay.(一旦高优先级的任务就绪，就能得到CPU的控制权)
- 时间片调度：每个任务都有相同的优先级，任务会运行固定的时间片个数或者遇到阻塞式的API函数，才会执行任务切换。

## 优先级反转
	高优先级的任务被低优先级的任务阻塞，导致高优先级的任务迟迟得不到调度。但其他中等优先级的任务却总能抢到CPU资源。-- 从现象上看，好像是中优先级的任务比高优先级的任务具有更高的优先权。

具体来说：当高优先级任务正等待信号量（此信号量被一个低优先级任务拥有着）的时候，一个介于两个任务优先之间的中等优先级任务开始执行——这就会导致一个高优先级任务在等待一个低优先级任务，而低优先级任务却无法执行类似死锁的情形发生。

一个具体的例子：假定一个进程中有三个线程Thread1(高）、Thread2（中）和Thread3（低），考虑下图的执行情况。
![[Pasted image 20230225175937.png]]
-   T0时刻，Thread3运行，并获得同步资源SYNCH1；
-   T1时刻，Thread2开始运行，由于优先级高于Thread3，Thread3被抢占（**未释放同步资源SYNCH1**），Thread2被调度执行；
-   T2时刻，Thread1抢占Thread2；
-   T3时刻，Thread1需要同步资源SYNCH1，但SYNCH1被更低优先级的Thread3所拥有，Thread1被挂起等待该资源
-   而此时线程Thread2和Thread3都处于可运行状态，Thread2的优先级大于Thread3的优先级，Thread2被调度执行。最终的结果是高优先级的Thread1迟迟无法得到调度，而中优先级的Thread2却能抢到CPU资源。

上述现象中，优先级最高的Thread1要得到调度，不仅需要等Thread3释放同步资源（**这个很正常**），而且还需要等待另外一个毫不相关的中优先级线程Thread2执行完成（**这个就不合理了**），会导致调度的实时性就很差了。

**解决方法1：优先级继承**
优先级继承就是为了解决优先级反转问题而提出的一种优化机制。其大致原理是让低优先级线程在获得同步资源的时候(如果有高优先级的线程也需要使用该同步资源时)，**临时**提升其优先级。以前其能更快的执行并释放同步资源。释放同步资源后再恢复其原来的优先级。
![[Pasted image 20230225180107.png]]
与上图相比，到了T3时刻，Thread1需要Thread3占用的同步资源SYNCH1，操作系统检测到这种情况后，就把 **Thread3的优先级提高到Thread1的优先级**。此时处于可运行状态的线程Thread2和Thread3中，Thread3的优先级大于Thread2的优先级，Thread3被调度执行。

Thread3执行到T4时刻，**释放了同步资源SYNCH1，操作系统恢复了Thread3的优先级**，Thread1获得了同步资源SYNCH1，重新进入可执行队列。处于可运行状态的线程Thread1和Thread2中，Thread1的优先级大于Thread2的优先级，所以Thread1被调度执行。

	通过优先级继承机制，可以有效解决优先级反转问题，使优先级最高的Thread1获得执行的时机提前。

**解决方法2：优先级天花板**
优先级天花板是当线程申请某共享资源时，把该线程的优先级提升到可访问这个资源的所有线程中的最高优先级，这个优先级称为该资源的优先级天花板。

这种方法简单易行，不必进行复杂的判断，不管线程是否阻塞了高优先级线程的运行，只要线程访问共享资源都会提升线程的优先级。

Ref: https://blog.csdn.net/Liangren_/article/details/115964700


## 任务之间如何通信
**队列、二值信号量、计数信号量、互斥量等方式**

**队列**
FreeRTOS中所有的通信和同步机制都是基于队列(FIFO)实现的。但是也可以使用(LIFO)的存储缓存，就是后进先出，FreeRTOS中的队列也提供了LIFO的存储缓冲机制。
1. 什么是队列？
	队列是数据结构中的一个概念，其最大的特性为先进先出。
2. 队列的特点
	多任务访问，任何任务都可以向队列中发送消息，或者从队列中提取消息。
	出队阻塞：当任务尝试从一个队列中读取消息时可以指定一个阻塞时间。
	入队阻塞：当任务尝试从一个队列中写入消息时可以指定一个阻塞时间。

**二值信号量与互斥量的区别**
1. 信号量常常用于控制对共享资源的访问和任务同步。
2. 二值信号量通常用于**互斥访问或同步**，二值信号量与互斥信号量非常类似，但是还是有一些细微的差别，**互斥信号量拥有优先级继承机制，二值信号量没有优先级继承**，因此二值信号量更适合用于同步(任务与任务或者任务与中断的同步)，而互斥信号量适用于简单的互斥访问。
	优先级继承：当一个互斥信号量正在被一个低优先级的任务使用，而此时有个高优先级的任务也尝试获取这个互斥信号量的话就会被阻塞。不过这个高优先级的任务会将低优先级任务的优先级提升到与自己相同的优先级，这个过程就是优先级继承。优先级继承尽可能的降低了高优先级任务处于阻塞态的时间，并且将已经出现的“优先级翻转”的影响降到最低。

3. 互斥信号量有优先级继承的机制，所以只能用在任务中，不能用于中断服务函数。
4. 中断服务函数中不能因为要等待互斥信号量而设置阻塞时间进入阻塞态。


## FreeRTOS的任务状态
- Running：运行态，任务处于实际运行状态，占用CPU使用权
- Ready：就绪态，任务已经能够运行，但是再等待高等级的任务释放CPU使用权
- Blocked：阻塞态，处于等待信号量，消息队列，事件标志组等等的状态。延时函数。
- Suspended：挂起态，类似于阻塞态，通过调用函数 vTaskSuspend()对指定任务进行挂起，挂起后这个任务将不被执行，只有调用函数 xTaskResume()才可以将这个任务从挂起态恢复。


## FreeRTOS任务优先级
数值越小，任务优先级越低。